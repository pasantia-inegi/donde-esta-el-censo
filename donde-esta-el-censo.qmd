---
# title: "modelo de innominación de documento"
# author: "Abril 2024"
format:
  revealjs:
    auto-stretch: false
    margin: 0
    slide-number: true
    scrollable: true
    preview-links: auto
    logo: imagenes/logo_portada2.png
    css: ine_quarto_styles.css
    # footer: <https://quarto.org>
---

#


<!---
# TODO: this does not work
 ![](imagenes/logo_portada2.png){.center style="width: 20%;"}   
--->

[]{.linea-superior} 
[]{.linea-inferior} 

<!---
 <img src="imagenes/logo_portada2.png" style="width: 20%"/>  
--->

<img src="imagenes/logo_portada2.png" width="20%"/>  


[**Ciencia de datos para el sector público:**]{.big-par .center-justified}
[**Aplicación "Dónde está el censo" y su stack tecnológico**]{.big-par .center-justified}
[**Proyecto Ciencia de Datos**]{.medium-par.center-justified}

[**Abril 2024**]{.big-par .center-justified}
---

## Contenidos {.medium-par}

- Contexto y objetivo
- Demostración de la aplicación
- Desafíos
- Estructura de la aplicación
- <HUGO_COSAS>
- Flask + Frontend
- Gunicorn
- Nginx
- Orquestado de contenedores
- ¿<MAS_HUGO_COSAS>?
- Conclusiones





## Contexto y objetivo

::: incremental

![](imagenes/logo-censo.png){.float-right width=25%  }

- En Chile, entre marzo y junio de 2024 se está ejecutando el Censo de Población y Vivienda.

- Por primera vez es un censo de derecho, durando 3 meses, en vez de un día.

- Esto implica que debió crearse una planificación sobre qué zonas serían censadas en distintos períodos.

- En la práctica, cada comuna (municipio) se divide en 4 ciclos que van siendo encuestados secuencialmente, 
en la medida que avanza el censo.

- En este contexto, se nos solicitó desarrollar una aplicación que mostrara qué sectores están siendo 
censados para la comuna seleccionada por el usuario.

:::


## Demostración de la aplicación


[Veamos cómo funciona la aplicación!](https://dondeestaelcenso.ine.gob.cl)


## Desafíos {.medium-par}

::: incremental

- Principalmente: es una aplicación de uso masivo, lo que implica que esta tiene que:
  - Ser capaz de escalar.
  - Ser eficiente.
  - Tener altas medidas de seguridad.
- Iremos explorando cómo los solucionamos durante la presentación

:::  


## Estructura de la aplicación

![](imagenes/diagrama.PNG)



## HUGO -----------------



## Flask + Frontend {.medium-par}

![](imagenes/app_code.png){width=60% .float-right}

::: incremental
- Como vimos anteriormente, Flask es un _microframework_ para desarrollo web de backend, 
famoso por ser sencillo, liviano y flexible. Es la base de otros frameworks más complejos como FastAPI.

- Flask funciona como backend de la aplicación, comunicándose con el frontend y manejando
las lógicas de la aplicación: ploteo, renderizado programático de valores específicos, formulario.

- Además, como herramienta de visualización se seleccionó Plotly, al ser Open Source. 
  - Anteriormente, se hicieron pruebas con Google, pero fueron desestimadas.

:::

## Flask + Frontend {.medium-par}

::: {.r-stack}

![](imagenes/frontend_app1.png){.fragment .fade-in-then-out .float-right}

![](imagenes/frontend_app2.png){.fragment .fade-in-then-out .float-right}

![](imagenes/frontend_app3.png){.fragment .float-right}
:::


- Esta aplicación requirió una comunicación fluida con el frontend. En particular, entre Python
y Javascript, lo que se realizó a través de fetch requests, una herramienta relativamente
reciente nativa de Javascript.
  
  - Esto permite que, por ejemplo, Python genere los datos del gráfico, pero Javascript se encargue del
  ploteo, poniendo la carga sobre los usuarios y no sobre nuestros servidores.
  
- Javascript se encarga también de las otras lógicas de la aplicación: funcionamiento de botones,
autocompletado de texto, tooltips, botón "loading", etc.

## Gunicorn {.medium-par}


``` yaml
services:
    flask-censo-1:
      container_name: flask-censo-1
      image: flask-censo
      build: ./flask_app
      command: gunicorn --workers 20 --bind 0.0.0.0:5000 app:app 

```

- Uno de los desafíos era escalar la aplicación y uno de los elementos que ayuda
con esto es Green Unicorn.


- Es un servidor HTTP Web Server Gateway Interface (WSGI).

- Crea tantos procesos trabajadores como cores hayan disponibles en la CPU, que
manejan las requests al servidor en paralelo.

- De esta forma gunicorn es quien sirve la aplicación.

![](imagenes/gunicorn-logo.png){ width=40% .float-right}

- Es ampliamente usado en Python por su simpleza, configurabilidad y eficiencia.

## Nginx

- Nginx actúa como parte de nuestra solución para la escalabilidad y la seguridad de la información.

- Actúa como proxy reverso y web server:
  - Acepta _requests_ de clientes y las distribuye al servidor backend (gunicorn), pasándole
  medidas de seguridad agregadas en su archivo de configuración. Luego, entrega la respuesta
  desde el servidor backend al cliente, haciendo parecer que el servidor proxy mismo entregó
  la respuesta.
  - Maneja el protocolo HTTP, además de servir los archivos estáticos de la página web.
  - El balance de la carga es externalizado a un servicio centralizado del INE.
  
## Nginx | Seguridad de la información




#


[<img src="imagenes/logo_portada2.png" width="20%"/>]{.center}


[**Ciencia de datos para el sector público:**]{.big-par .center-justified}
[**Aplicación "Dónde está el censo" y su stack tecnológico**]{.big-par .center-justified}
[**Proyecto Ciencia de Datos**]{.medium-par.center-justified}

[**Abril 2024**]{.big-par .center-justified}



[]{.linea-superior} 
[]{.linea-inferior} 

